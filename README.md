# Vibe Coding 企业级协作脚手架

这是一个基于 Cursor 的企业级 AI 协作脚手架，通过标准化流程确保 AI 与人的协作可控、可复用、可持续。

## 快速开始

### 1. 初始化项目（首次使用必做）

在 Cursor 对话框中输入：

```
@init
```

AI 将自动：
- 扫描项目结构和技术栈
- 询问项目技术规范
- 生成 `.cursor/guider.md`（项目协作宪法）

**注意**：`guider.md` 定义了项目的技术边界、工具类、规范等，后续所有开发都必须遵守。

---

### 2. 开发新功能

#### 步骤 1：准备原始需求

在 `.cursor/features/{功能名称}/raw/` 目录下放置：
- 需求文档（Word、PDF、Markdown 等）
- 原型图、设计稿
- 业务描述文件
- 任何相关的参考材料

**示例目录结构**：
```
.cursor/
└── features/
    └── user-login/
        └── raw/
            ├── 需求文档.md
            ├── 原型图.png
            └── 业务规则.txt
```

#### 步骤 2：触发开发流程

在 Cursor 对话框中输入：

```
@feature user-login
```

AI 将按以下 4 个阶段执行：

**Phase 1: 需求澄清**
- AI 读取 `raw/` 目录下的原始材料
- AI 主动提问，填补需求漏洞
- ⚠️ **此阶段禁止写代码**

**Phase 2: 锚点锁定**
- AI 生成 `prd_v1.md` 和 `trd_v1.md`
- ⚠️ **必须等你确认后，才能进入下一阶段**

**Phase 3: 受控实现**
- AI 严格按照 TRD 编写代码和测试
- 自动复用 `guider.md` 中定义的工具类

**Phase 4: 自愈验证**
- AI 自动运行测试
- 如有错误，自动修复并重试（最多 3 次）

---

### 3. 迭代现有功能

在 Cursor 对话框中输入：

```
@iterate user-login 增加手机号登录功能
```

AI 将：
1. 自动读取该功能的最新版本文档（`prd_v{n}.md`、`trd_v{n}.md`）
2. 分析变更影响范围
3. 生成新版本文档（`prd_v{n+1}.md`、`trd_v{n+1}.md`），包含 ChangeLog
4. 等你确认后，进行最小化代码修改
5. 运行回归测试，确保不破坏原有功能

**重要**：
- 每次迭代都会创建新版本文档，不会覆盖旧版本
- 如果功能不存在，AI 会提示先使用 `@feature` 创建

---

## 目录结构

```
.cursor/
├── skills/              # AI 技能定义（无需修改）
│   ├── init.md         # 初始化技能
│   ├── feature.md      # 功能开发技能
│   └── iterate.md      # 迭代技能
├── features/           # 功能文档存放目录
│   └── {功能名称}/
│       ├── raw/        # 原始需求材料（你放置）
│       ├── prd_v1.md   # 产品需求文档（AI 生成）
│       ├── trd_v1.md   # 技术实现文档（AI 生成）
│       ├── prd_v1.1.md # 迭代版本（AI 生成）
│       └── trd_v1.1.md # 迭代版本（AI 生成）
└── guider.md           # 项目协作宪法（AI 生成，可手动修改）
```

---

## 使用场景

| 场景 | 使用技能 | 示例命令 |
|------|---------|---------|
| 首次使用项目 | `@init` | `@init` |
| 开发新功能 | `@feature` | `@feature user-login` |
| 修改现有功能 | `@iterate` | `@iterate user-login 增加验证码功能` |
| 修复 Bug | `@iterate` | `@iterate user-login 修复登录超时问题` |
| 代码调试/解释 | 直接对话 | 无需使用技能 |

---

## 常见问题

### Q: 可以跳过 Phase 2 直接让 AI 写代码吗？

**不可以**。跳过文档阶段会导致：
- 需求理解不一致
- 后续无法追溯决策
- 团队协作困难

如果需求很紧急，可以在 Phase 2 快速确认文档，但不要跳过。

### Q: 开发中途想改需求怎么办？

**不要**在 `@feature` 的 Phase 3 中通过聊天改需求。

正确做法：
1. 如果还没进入 Phase 3：回到 Phase 2，修改 PRD/TRD
2. 如果已经进入 Phase 3：先完成当前功能，然后用 `@iterate` 进行迭代

### Q: `guider.md` 可以修改吗？

**可以**。`guider.md` 是项目级规范，应该由项目 Owner 维护。

当项目引入新依赖（如 Redis、Kafka）或变更技术栈时，需要更新 `guider.md`。

### Q: 如何查看某个功能的历史版本？

直接查看 `.cursor/features/{功能名称}/` 目录下的文件：
- `prd_v1.md` → `prd_v1.1.md` → `prd_v2.md` 等
- 每个版本都包含变更记录

### Q: 三个技能可以同时使用吗？

**不建议**。每个技能都是完整的工作流，应该：
- 先完成 `@init`（如果还没做）
- 用 `@feature` 开发新功能
- 用 `@iterate` 迭代已有功能

---

## 最佳实践

✅ **推荐做法**：
- 在 Phase 2 阶段，把 AI 当作“乙方”来审核，大胆修改 PRD/TRD
- 每次迭代只解决一个或一批相似的变更点
- 如果 AI 引入了新依赖，检查它是否更新了 `guider.md`

❌ **常见错误**：
- 跳过 Phase 1 直接让 AI 写代码
- 在 Phase 3 阶段通过聊天修改需求
- 用 `@feature` 重新生成一个已有的功能（应该用 `@iterate`）
- 直接在代码里改，不更新文档（导致文档腐烂）

---

## 技术支持

如有问题，请检查：
1. `.cursor/guider.md` 是否存在且完整
2. 功能目录结构是否正确
3. 原始需求文件是否已放置在 `raw/` 目录
